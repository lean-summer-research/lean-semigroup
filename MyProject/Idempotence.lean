import MyProject.WithOne

/-!
# Idempotent Elements in Finite Semigroups

This file defines properties related to idempotent elements in finite semigroups.

## Main Definitions

* `Semigroup.exists_repeating_pow` - in finite semigroups, powers of any element eventually repeat
* `Semigroup.pow_idempotent_unique` - if two powers of an element are idempotent, they are equal
* `Semigroup.exists_idempotent_pow` - every element in a finite semigroup has an idempotent power
* `Monoid.exists_idempotent_pow` - monoid version defined with Nat pow rather than Pnat pow

## Implementation notes

`Monoid.exists_idempotent_pow` is useful when reasoning about elements in MONOIDS, when the theorem
is needed in terms of `Nat` powers greater than `0` rather than `PNat` powers. In the `ùìì = ùìô`
theorem for finite semigroups (found in `GreensRelations.Basic.lean`), we use this Monoid version
because it applies to elements in the monoid `S¬π`. This allows us to reason with mathlib's `pow`
operation and associated theorems instead of relying on our `PNat` power operation.
-/

namespace Semigroup

variable {S} [Semigroup S]

/-- If `x` is idempotent, then raising `x` to any positive power yields `x`. -/
lemma pow_succ_eq {x : S} (n : ‚Ñï+) (h_idem : IsIdempotentElem x) : x ^ n = x := by
  induction n using PNat.recOn with
  | one    => rfl
  | succ n' ih => rw [‚Üê PNat.pow_succ, ih, h_idem]

/-- If `S` is finite then for any `x : S` there exist
exponents such that the power eventually repeats. -/
lemma exists_repeating_pow [Finite S] (x : S) : ‚àÉ (m n : ‚Ñï+), x ^ m * x ^ n = x ^ m := by
  obtain ‚ü®o, p, hop, heq‚ü© : ‚àÉ o p : ‚Ñï+, o ‚â† p ‚àß x ^ o = x ^ p := by
    apply Finite.exists_ne_map_eq_of_infinite
  simp_all only [ne_eq, PNat.pow_add]; pnat_to_nat
  rcases (Nat.lt_or_gt_of_ne hop) with (o_lt_p | p_lt_o)
  ¬∑ use o, p - o; simp_all
  ¬∑ use p, o - p; simp_all

/-- If two powers of an element `x : S` are idempotent, then they are equal. -/
theorem pow_idempotent_unique {x : S} {m n : ‚Ñï+}
(hm : IsIdempotentElem (x ^ m)) (hn : IsIdempotentElem (x ^ n)) : x ^ m = x ^ n := by
  rw [‚Üê pow_succ_eq n hm, PNat.pow_right_comm, pow_succ_eq m hn]

/-- In a finite semigroup `S`, the subsemigroup generated by any element contains an idempotent -/
theorem exists_idempotent_pow [Finite S] (x : S) : ‚àÉ (m : ‚Ñï+), IsIdempotentElem (x ^ m) := by
  -- `n` is the length of the pre-period (tail),
  --`loop_size` is the length of the cycle.
  obtain ‚ü®n, loop_size, loop_eq‚ü© := exists_repeating_pow x
  -- The `loop` lemma formalizes that once powers of `a` enter the cycle,
  -- adding further multiples of `loop_size` to the exponent doesn't change the result.
  have loop : ‚àÄ (loop_count start : ‚Ñï+),
      n < start ‚Üí x ^ (start + loop_count * loop_size) = x ^ start := by
    intro loop_count
    induction loop_count using PNat.recOn with
    | one =>
      intro start n_lt_start
      obtain ‚ü®diff, hdiff‚ü© := PNat.exists_eq_add_of_lt n_lt_start
      simp_all only [PNat.pow_add, one_mul, ‚Üê PNat.pow_add, mul_assoc]
    | succ loop_count' ih =>
      intro start n_lt_start
      obtain ‚ü®diff, hdiff‚ü© := PNat.exists_eq_add_of_lt n_lt_start
      subst hdiff
      specialize ih (diff + n)
      apply ih at n_lt_start
      have h_arith :
        (loop_count' + 1) * loop_size = (loop_count' * loop_size) + loop_size := by ring
      simp_rw [h_arith, ‚Üê add_assoc, ‚Üê PNat.pow_add] at *
      rw [n_lt_start, mul_assoc, loop_eq]
  -- We choose `2 * n * loop_size` as the exponent for our idempotent element.
  -- This ensures the exponent is beyond the pre-period `n` and is a multiple of `loop_size`.
  use 2 * n * loop_size
  unfold IsIdempotentElem
  specialize loop (2 * n) (2 * n * loop_size)
  simp_all only [PNat.pow_add]
  -- Apply the `loop` lemma. The condition `n < 2 * n * loop_size` is met by `PNat.n_lt_2nm`.
  apply loop
  exact PNat.n_lt_2nm n (loop_size)

end Semigroup

namespace Monoid

variable {M} [Monoid M]

/-- Idempotent elements are stable under positive powers in Monoids -/
lemma pow_succ_eq {x : M} {n : ‚Ñï} (h_idem : IsIdempotentElem x):
    x ^ (n + 1) = x := by
  induction n with
  | zero => simp_all
  | succ n' ih => rw [pow_succ, ih, h_idem]

/-- Every element in a finite monoid has an idempotent power -/
theorem exists_idempotent_pow [Finite M] (x : M) :
    ‚àÉ (n : ‚Ñï), IsIdempotentElem (x ^ n) ‚àß n ‚â† 0:= by
  obtain ‚ü®m, hm‚ü© := Semigroup.exists_idempotent_pow x
  use m; simp_all only [IsIdempotentElem]
  constructor
  ¬∑ rwa [‚Üê PNat.pow_pnat_to_nat]
  ¬∑ simp [PNat.ne_zero]

end Monoid
